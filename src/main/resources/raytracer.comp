#version 450

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Camera {
    vec3 origin;
    vec3 look_at;
    vec3 up;
    float fov;
    float focus_dist;
    float defocus_blur;

    vec3 pixel00_loc;
    vec3 pixel_delta_u, pixel_delta_v;
};


Camera camera_init() {
    ivec2 dimensions = imageSize(screen);

    Camera cam;
    cam.origin = vec3(0, 0, 0);
    cam.look_at = vec3(0, 0, -1);
    cam.up = vec3(0, 1, 0);
    cam.fov = radians(90.0);
    cam.focus_dist = 1;
    cam.defocus_blur = 0;

    float h = tan(cam.fov / 2);
    float viewport_height = 2 * h * cam.focus_dist;
    float viewport_width = viewport_height * dimensions.x / dimensions.y;

    vec3 w = normalize(cam.origin - cam.look_at);
    vec3 u = normalize(cross(cam.up, w));
    vec3 v = cross(w, u);

    vec3 viewport_u = viewport_width * u;
    vec3 viewport_v = viewport_height * -v;

    cam.pixel_delta_u = viewport_u / dimensions.x;
    cam.pixel_delta_v = viewport_v / dimensions.y;

    // might be + 0.5 * viewport_v
    vec3 viewport_upper_left = cam.origin - cam.focus_dist * w - viewport_u / 2 - viewport_v / 2;

    cam.pixel00_loc = viewport_upper_left + 0.5 * (cam.pixel_delta_u + cam.pixel_delta_v);

    return cam;
}

vec3 ray_at(Ray r, float t) {
    return r.origin + t * r.direction;
}


Ray camera_get_ray(Camera cam, ivec2 pixel_coords) {
    vec3 offset = vec3(0, 0, 0);  // todo: make random offset ([-0.5, 0.5], [-0.5, 0.5], 0)
    vec3 pixel_sample = cam.pixel00_loc + ((pixel_coords.x + offset.x) * cam.pixel_delta_u) + ((pixel_coords.y + offset.y) * cam.pixel_delta_v);

    vec3 ray_origin = cam.origin;  // todo: add defocus stuff
    vec3 ray_direction = normalize(pixel_sample - cam.origin);

    return Ray(ray_origin, ray_direction);
}

float hit(vec3 center, float radius, Ray ray) {
    vec3 oc = center - ray.origin;
    float a = dot(ray.direction, ray.direction);
    float b = -2 * dot(ray.direction, oc);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4 * a * c;

    if (discriminant < 0) {
        return -1;
    } else {
        return (-b - sqrt(discriminant)) / (2 * a);
    }
}

vec3 camera_ray_color(Camera cam, ivec2 pixel_coords) {
    Ray r = camera_get_ray(cam, pixel_coords);

    float t = hit(vec3(0, 0, -1), 0.5, r);
    if (t > 0) {
        vec3 normal = normalize(ray_at(r, t) - vec3(0, 0, -1));
        return 0.5 * (normal + 1);
    }

    vec3 unit_direction = normalize(r.direction);
    float a = 0.5 * (unit_direction.y + 1.0);
    return (1 - a) * vec3(1, 1, 1) + a * vec3(0.5, 0.7, 1.0);
}

void main() {
    ivec2 dimensions = imageSize(screen);
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    pixel_coords = ivec2(pixel_coords.x, dimensions.y - pixel_coords.y);

    Camera cam = camera_init();
    vec3 pixel = camera_ray_color(cam, ivec2(gl_GlobalInvocationID.xy));

    imageStore(screen, pixel_coords, vec4(pixel, 1));
}