#version 450

#define MAX_COUNT 100

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;

layout(std430, binding = 0) buffer MaterialsBuffer {
    vec3 colors[MAX_COUNT];
};

layout(std430, binding = 1) buffer ObjectsBuffer {
    vec3 centers[MAX_COUNT];
    float radii[MAX_COUNT];
    int material_ids[MAX_COUNT];
};

uniform int num_objects;
uniform int num_materials;

struct HitRecord {
    vec3 p;
    vec3 normal;
    float t;
    bool front_face;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Camera {
    vec3 origin;
    vec3 look_at;
    vec3 up;
    float fov;
    float focus_dist;
    float defocus_blur;

    vec3 pixel00_loc;
    vec3 pixel_delta_u, pixel_delta_v;
};


void set_face_normal(Ray r, vec3 outward_normal, inout HitRecord rec) {
    rec.front_face = dot(r.direction, outward_normal) < 0;
    rec.normal = rec.front_face ? outward_normal : -outward_normal;
}


float length_squared(vec3 v) {
    return dot(v, v);
}


Camera camera_init() {
    ivec2 dimensions = imageSize(screen);

    Camera cam;
    cam.origin = vec3(0, 0, 0);
    cam.look_at = vec3(0, 0, -1);
    cam.up = vec3(0, 1, 0);
    cam.fov = radians(90.0);
    cam.focus_dist = 1;
    cam.defocus_blur = 0;

    float h = tan(cam.fov / 2);
    float viewport_height = 2 * h * cam.focus_dist;
    float viewport_width = viewport_height * dimensions.x / dimensions.y;

    vec3 w = normalize(cam.origin - cam.look_at);
    vec3 u = normalize(cross(cam.up, w));
    vec3 v = cross(w, u);

    vec3 viewport_u = viewport_width * u;
    vec3 viewport_v = viewport_height * -v;

    cam.pixel_delta_u = viewport_u / dimensions.x;
    cam.pixel_delta_v = viewport_v / dimensions.y;

    // might be + 0.5 * viewport_v
    vec3 viewport_upper_left = cam.origin - cam.focus_dist * w - viewport_u / 2 - viewport_v / 2;

    cam.pixel00_loc = viewport_upper_left + 0.5 * (cam.pixel_delta_u + cam.pixel_delta_v);

    return cam;
}

vec3 ray_at(Ray r, float t) {
    return r.origin + t * r.direction;
}


Ray camera_get_ray(Camera cam, ivec2 pixel_coords) {
    vec3 offset = vec3(0, 0, 0);  // todo: make random offset ([-0.5, 0.5], [-0.5, 0.5], 0)
    vec3 pixel_sample = cam.pixel00_loc + ((pixel_coords.x + offset.x) * cam.pixel_delta_u) + ((pixel_coords.y + offset.y) * cam.pixel_delta_v);

    vec3 ray_origin = cam.origin;  // todo: add defocus stuff
    vec3 ray_direction = normalize(pixel_sample - cam.origin);

    return Ray(ray_origin, ray_direction);
}

bool hit_sphere(vec3 center, float radius, Ray ray, float ray_tmin, float ray_tmax, inout HitRecord rec) {
    vec3 oc = center - ray.origin;
    float a = dot(ray.direction, ray.direction);
    float h = dot(ray.direction, oc);
    float c = length_squared(oc) - radius * radius;
    float discriminant = h * h - a * c;

    if (discriminant < 0) {
        return false;
    }

    float sqrtd = sqrt(discriminant);

    // Find the nearest root that lies in the acceptable range
    float root = (h - sqrtd) / a;
    if (root <= ray_tmin || ray_tmax <= root) {
        root = (h + sqrtd) / a;
        if (root <= ray_tmin || ray_tmax <= root) {
            return false;
        }
    }

    rec.t = root;
    rec.p = ray_at(ray, rec.t);
    vec3 outward_normal = (rec.p - center) / radius;
    set_face_normal(ray, outward_normal, rec);

    return true;
}

bool hit_world(Ray r, float t_min, float t_max, inout HitRecord rec) {
    HitRecord temp_rec;
    bool hit_anything = false;
    float closest_so_far = t_max;

    for (int i = 0; i < num_objects; i++) {
        if (hit_sphere(centers[i], radii[i], r, t_min, closest_so_far, temp_rec)) {
            hit_anything = true;
            closest_so_far = temp_rec.t;
            rec = temp_rec;
        }
    }

    return hit_anything;
}

vec3 camera_ray_color(Camera cam, ivec2 pixel_coords) {
    Ray r = camera_get_ray(cam, pixel_coords);

    HitRecord rec;
    if (hit_world(r, 0, 1000, rec)) {
        return 0.5 * (rec.normal + 1);
    }

    vec3 unit_direction = normalize(r.direction);
    float a = 0.5 * (unit_direction.y + 1.0);
    return (1 - a) * vec3(1, 1, 1) + a * vec3(0.5, 0.7, 1.0);
}

void main() {
    ivec2 dimensions = imageSize(screen);
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    pixel_coords = ivec2(pixel_coords.x, dimensions.y - pixel_coords.y);

    Camera cam = camera_init();
    vec3 pixel = camera_ray_color(cam, ivec2(gl_GlobalInvocationID.xy));

    imageStore(screen, pixel_coords, vec4(pixel, 1));
}