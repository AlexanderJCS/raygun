#version 450

#define MAX_COUNT 100

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;

struct Material {
    vec3 albedo;
    vec3 emissionColor;
    float emissionStrength;
};

layout(std430, binding = 0) buffer MaterialsBuffer {
    Material materials[MAX_COUNT];
};

struct Sphere {
    vec3 center;
    float radius;
    int material_id;
};

layout(std430, binding = 1) buffer ObjectsBuffer {
    Sphere objects[MAX_COUNT];
};

uniform int num_objects;
uniform int num_materials;
uniform int frame_counter;

struct HitRecord {
    vec3 p;
    vec3 normal;
    float t;
    int material_id;
    bool front_face;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Camera {
    vec3 origin;
    vec3 look_at;
    vec3 up;
    float fov;
    float focus_dist;
    float defocus_blur;

    vec3 pixel00_loc;
    vec3 pixel_delta_u, pixel_delta_v;
};

float rand_seed = dot(gl_GlobalInvocationID.xy, gl_GlobalInvocationID.xy) + frame_counter;
int rand_counter = 0;

float length_squared(vec3 v) {
    return dot(v, v);
}

// Credit for the hash, float_construct, and random(float x) functions: https://stackoverflow.com/a/17479300/18758660
uint hash( uint x ) {
    x += ( x << 10u );
    x ^= ( x >>  6u );
    x += ( x <<  3u );
    x ^= ( x >> 11u );
    x += ( x << 15u );
    return x;
}

float float_construct(uint m ) {
    const uint ieee_mantissa = 0x007FFFFFu; // binary32 mantissa bitmask
    const uint ieee_one = 0x3F800000u;      // 1.0 in IEEE binary32

    m &= ieee_mantissa;                     // Keep only mantissa bits (fractional part)
    m |= ieee_one;                          // Add fractional part to 1.0

    float  f = uintBitsToFloat( m );        // Range [1:2]
    return f - 1.0;                         // Range [0:1]
}

float random(float x) {
    return float_construct(hash(floatBitsToUint(x)));
}

float random() {
    return random(rand_seed + rand_counter++);
}

vec3 random_vec3() {
    return vec3(random(), random(), random());
}

vec3 random_sphere() {
    vec3 p;
    do {
        p = 2.0 * random_vec3() - vec3(1.0);
    } while (length_squared(p) >= 1.0);
    return p;
}

vec3 random_hemisphere(vec3 normal) {
    vec3 in_unit_sphere = random_sphere();
    if (dot(in_unit_sphere, normal) > 0.0) {
        return in_unit_sphere;
    } else {
        return -in_unit_sphere;
    }
}

void set_face_normal(Ray r, vec3 outward_normal, inout HitRecord rec) {
    rec.front_face = dot(r.direction, outward_normal) < 0;
    rec.normal = rec.front_face ? outward_normal : -outward_normal;
}

Camera camera_init() {
    ivec2 dimensions = imageSize(screen);

    Camera cam;
    cam.origin = vec3(0, 0, 0);
    cam.look_at = vec3(0, 0, -1);
    cam.up = vec3(0, 1, 0);
    cam.fov = radians(90.0);
    cam.focus_dist = 1;
    cam.defocus_blur = 0;

    float h = tan(cam.fov / 2);
    float viewport_height = 2 * h * cam.focus_dist;
    float viewport_width = viewport_height * dimensions.x / dimensions.y;

    vec3 w = normalize(cam.origin - cam.look_at);
    vec3 u = normalize(cross(cam.up, w));
    vec3 v = cross(w, u);

    vec3 viewport_u = viewport_width * u;
    vec3 viewport_v = viewport_height * -v;

    cam.pixel_delta_u = viewport_u / dimensions.x;
    cam.pixel_delta_v = viewport_v / dimensions.y;

    // might be + 0.5 * viewport_v
    vec3 viewport_upper_left = cam.origin - cam.focus_dist * w - viewport_u / 2 - viewport_v / 2;

    cam.pixel00_loc = viewport_upper_left + 0.5 * (cam.pixel_delta_u + cam.pixel_delta_v);

    return cam;
}

vec3 ray_at(Ray r, float t) {
    return r.origin + t * r.direction;
}


Ray camera_get_ray(Camera cam, ivec2 pixel_coords) {
    vec3 offset = vec3(0, 0, 0);  // todo: make random offset ([-0.5, 0.5], [-0.5, 0.5], 0)
    vec3 pixel_sample = cam.pixel00_loc + ((pixel_coords.x + offset.x) * cam.pixel_delta_u) + ((pixel_coords.y + offset.y) * cam.pixel_delta_v);

    vec3 ray_origin = cam.origin;  // todo: add defocus stuff
    vec3 ray_direction = normalize(pixel_sample - cam.origin);

    return Ray(ray_origin, ray_direction);
}

bool hit_sphere(Sphere sphere, Ray ray, float ray_tmin, float ray_tmax, inout HitRecord rec) {
    vec3 oc = sphere.center - ray.origin;
    float a = dot(ray.direction, ray.direction);
    float h = dot(ray.direction, oc);
    float c = length_squared(oc) - sphere.radius * sphere.radius;
    float discriminant = h * h - a * c;

    if (discriminant < 0) {
        return false;
    }

    float sqrtd = sqrt(discriminant);

    // Find the nearest root that lies in the acceptable range
    float root = (h - sqrtd) / a;
    if (root <= ray_tmin || ray_tmax <= root) {
        root = (h + sqrtd) / a;
        if (root <= ray_tmin || ray_tmax <= root) {
            return false;
        }
    }

    rec.t = root;
    rec.p = ray_at(ray, rec.t);
    rec.material_id = sphere.material_id;
    vec3 outward_normal = (rec.p - sphere.center) / sphere.radius;
    set_face_normal(ray, outward_normal, rec);

    return true;
}

bool hit_world(Ray r, float t_min, float t_max, inout HitRecord rec) {
    HitRecord temp_rec;
    bool hit_anything = false;
    float closest_so_far = t_max;

    for (int i = 0; i < num_objects; i++) {
        if (hit_sphere(objects[i], r, t_min, closest_so_far, temp_rec)) {
            hit_anything = true;
            closest_so_far = temp_rec.t;
            rec = temp_rec;
        }
    }

    return hit_anything;
}


bool material_scatter(int material_id, Ray r_in, HitRecord rec, inout vec3 attenuation, inout Ray scattered) {
    if (material_id == 0 || material_id == 1) {
        vec3 target = rec.p + rec.normal;
        scattered.origin = rec.p;
        scattered.direction = random_hemisphere(normalize(rec.normal));
        attenuation = materials[rec.material_id].albedo;
        return true;
    }

    return false;
}


vec3 ray_color(Ray r) {
    vec3 color = vec3(1.0); // Accumulated color
    vec3 attenuation = vec3(1.0); // Attenuation for each ray segment

    for (int i = 0; i < 10; i++) { // Max depth
        HitRecord rec;
        if (hit_world(r, 0.001, 1000.0, rec)) {
            // If the ray hits an object, compute scattered ray
            Ray scattered;
            if (material_scatter(rec.material_id, r, rec, attenuation, scattered)) {
                r = scattered; // Update the current ray
                color *= attenuation; // Apply the material's attenuation
            } else {
                // Absorbed ray (no scatter): return black
                return color;
            }
        } else {
            // Missed all objects: apply background gradient
            vec3 unit_direction = normalize(r.direction);
            float t = 0.5 * (unit_direction.y + 1.0);
            vec3 background = (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
            return color * background; // Blend with accumulated color
        }
    }

    // Max depth reached: return accumulated color
    return color;
}



vec3 render(Camera cam, ivec2 pixel_coords) {
    // 10 is max depth
    Ray r = camera_get_ray(cam, pixel_coords);
    return ray_color(r);
}

void main() {
    ivec2 dimensions = imageSize(screen);
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    pixel_coords = ivec2(pixel_coords.x, dimensions.y - pixel_coords.y);

    Camera cam = camera_init();
    vec3 newPixel = render(cam, ivec2(gl_GlobalInvocationID.xy));

    vec3 oldPixel = imageLoad(screen, pixel_coords).rgb;
    vec3 pixel = (oldPixel * float(frame_counter) + newPixel) / float(frame_counter + 1);

    imageStore(screen, pixel_coords, vec4(pixel, 1));
}